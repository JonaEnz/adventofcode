#!fsharp

open System.IO
let lines = File.ReadAllLines("test.txt")

type Coords = {x:int;y:int;z:int}
type Scanner = {coords:Coords list;}

let parseScanner (arr: string[]) =
    let s = Array.takeWhile (fun (s:string) -> s="" |> not) (arr[1..])
    let arr' = arr[s.Length+2..]
    let scanners = 
        Array.map (fun (l:string) -> l.Split(",") |> fun (l) -> {x=int l[0];y=int l[1];z=int l[2]}) s
        |> Array.toList |> fun l -> {coords=l;}
    scanners,arr'
let scanners = Array.unfold (fun s -> if Array.length s <= 1 then None else Some (parseScanner s)) lines |> Array.toList

#!fsharp

let rotate s =
    let rotate s = [s; {x =(s.z);y=s.y; z=(-s.x)}; {x =(-s.z); y=s.y; z=(s.x);}; {x =(-s.x); y=s.y; z=(-s.z);}]
    let xTop   s = [{x=(s.y);y= (s.x); z=(-s.z)}; {x=(s.y);y= (-s.x); z=(s.z)}]
    let yTop   s = [{x=(s.x);y= (s.y); z=(s.z)}; {x=(s.x);y= (-s.y); z=(-s.z)}]
    let zTop   s = [{x=(s.y);y= (s.z); z=(s.x)}; {x=(s.y);y= -(s.z); z=(-s.x)}]
    [s]
    |> fun l -> List.append (List.append (List.map xTop l) (List.map yTop l)) (List.map zTop l)
    |> List.collect id
    |> List.map rotate |> List.collect id

#!fsharp

let rotateAll coords =
    List.map rotate coords
    |> List.transpose

let subFromAll c coords = List.map (fun c -> {(c:Coords) with x= c.x - coords.x; y=c.y - coords.y; z=c.z - coords.z;}) c
let addToAll c coords = List.map (fun c -> {(c:Coords) with x= c.x + coords.x; y=c.y + coords.y; z=c.z + coords.z;}) c

let normalize s = subFromAll s s[0]

let getMatch total c2 = 
    let c2' = List.map (fun c -> c, subFromAll c2 c) c2
    List.allPairs total c2'
    |> List.filter (fun (t,s) -> Set.intersect (Set.ofList (snd t)) (Set.ofList (snd s))|> Seq.length |> (<=) 12)
    |> fun l -> 
        if List.isEmpty l then None 
        else
            let (t,s) = List.head l
            Some (addToAll (snd s) (fst t), subFromAll [fst t] (fst s) |> List.head)

let merge s1 s2 = Set.union (Set.ofList s1) (Set.ofList s2) |> Seq.toList

let addToTotal total add =
    let total' = List.map (fun t -> t, subFromAll total t) total
    let m = List.choose (fun s -> getMatch total' s) add
    match m with
    | [] -> None
    | m :: ms -> Some (merge total (fst m), snd m)

let iterateQueue total pos queue =
    List.map (fun s ->s, rotateAll s.coords) queue
    |> List.fold (fun (total,pos,q) t -> 
        match addToTotal total (snd t) with
        | Some total' -> (normalize (fst total')), (snd total') :: pos, q
        | None -> total, pos , (fst t) :: q
        ) 
        (total, pos, [])

let rec iterateAll total pos queue=
    printfn "%d" (List.length queue)
    let (total', pos', queue') = iterateQueue total pos queue
    match queue', List.length queue' < List.length queue with
    | _ :: _, true -> iterateAll total' pos' queue'
    | _, _ -> total', pos'

let solution = iterateAll (normalize scanners[0].coords) [] scanners
printfn "Part1: %d" (solution |> snd |> List.length)

solution
|> fst
|> fun l -> List.allPairs l l
|> List.filter (fun (a,b) -> a<>b)
|> List.map (fun (a,b) -> abs (a.x-b.x) + abs (a.y-b.y) + abs (a.z-b.z))
|> List.max
