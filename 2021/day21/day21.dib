#!fsharp

open System.IO
let lines = File.ReadAllLines("input.txt")

type Player = {pos:int; score:int64;}

let playerStart i = lines[i-1].Split(": ")[1] |> fun p -> {pos=(int p);score=0L}

#!fsharp

let deterministicdie = Seq.initInfinite (fun i -> i, (i % 100) + 1)

let move player (die: (int*int) seq) =
    let mv = Seq.take 3 die |> Seq.sumBy (snd)
    let nextPos = ((player.pos - 1 + mv) % 10) + 1
    {pos= nextPos; score=player.score + int64 nextPos}, Seq.skip 3 die

let rec play play1 play2 (die: (int*int) seq) =
    let (play1', die') = move play1 die
    let (play2', die'') = move play2 die'
    match play1', play2' with
    | p, _ when p.score >= 1000 -> 1, play1', play2', Seq.head die''
    | _, p when p.score >= 1000 -> 2, play1', play2', Seq.head die''
    | _, _ -> play play1' play2' die''

play (playerStart 1) (playerStart 2) deterministicdie
|> fun (win, p1, p2, die) -> (if win=2 then p1.score else p2.score) * (fst die |> int64)

#!fsharp

type State = {position:int; score:int64; prob:int64;}

let probs = 
    List.map (fun ((i,j),k) -> i+j+k) (List.allPairs (List.allPairs [1..3] [1..3]) [1..3])
    |> List.countBy id
    |> List.map (fun (k,v) -> k, int64 v)

let step (l:State list) =
    let ps (s,s2)=
        List.map (fun (i1,i2) ->
            ({position= ((s.position - 1 + i1) % 9) + 1; 
            score = s.score + (int64 ((s.position - 1 + i1) % 9) + 1L); prob = s.prob * i2;})
            ) probs
    List.map ps l
    |> List.collect id

let rec play2 (player1: (State list)) player2 win1 win2=
    let step1' = step player1
    let step2' = step player2
    let (wins,conts) =
        List.allPairs step1' step2'
        |> List.partition  (fun (p1,p2) -> p1.score >= 21 || p2.score >= 21)
    let (w1,w2) =
        wins
        |> List.fold (fun (w1,w2) (p1,p2) ->
            match p1,p2 with
            | p, _ when p.score >= 21 -> w1 + p.prob, w2
            | _, p when p.score >= 21 -> w1, w2 + 3L * p.prob
            | _, _ -> w1, w2
            ) (win1, win2)
    //printfn "%A" wins
    match conts with
    | [] -> (w1 / 3L), (w2 / 3L)
    | c -> 
        let a = List.map fst c
        let b = List.map snd c
        play2 a b w1 w2


let (w1,w2) = play2 [{position=4; score=0L; prob=1L}] [{position=8; score=0L; prob=1L}] 0L 0L
w1,w2
